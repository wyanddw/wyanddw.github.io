[{"title":"hexo配置操作","date":"2017-03-19T12:10:03.000Z","path":"2017/03/19/post/","text":"平时常用命令整理hexo new post &quot;新建文章&quot; hexo c 清除旧的public文件夹 hexo g 生成静态文件 hexo d 发布到github上 hexo s -p 5000","tags":[{"name":"博客","slug":"博客","permalink":"https://wyanddw.github.io/tags/博客/"}]},{"title":"Hello World","date":"2017-03-17T14:12:17.459Z","path":"2017/03/17/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"并发编程","date":"2017-03-17T02:14:36.000Z","path":"2017/03/17/hello/","text":"摘要:隐式锁和显示锁，死锁正文: 隐式锁所谓的隐式锁就是指synchronized标记，此标记可以加在method上，也可以加在代码块上。加在代码块上的效率较高，同时加锁的对象一般定义为： &gt;代码 private byte[] lock = new byte[1]; public void mehod(){ synchronized(lock){ //TODO } } 显示锁Lock和ReentrantLockLock接口，提供了无条件的，可轮询的，定时的，可中断的锁获取操作，所有加锁和解锁的方法都是显示的 void lock()获取锁，如果锁不可用，出于线程调度的目的，将禁用当前线程，并且在获得锁之前，该线程一直处于休眠状态 void lockInterruptibly() throws InterruptedExceptionlock 优先考虑获取锁，待获取锁成功后，才响应中断。lockInterruptibly 优先考虑响应中断，而不是响应锁的普通获取或重入获取。ReentrantLock.lockInterruptibly允许在等待时由其它线程调用等待线程的Thread.interrupt方法来中断等待线程的等待而直接返回,这时不用获取锁，而会抛出一个InterruptedException。ReentrantLock.lock方法不允许Thread.interrupt中断,即使检测到Thread.isInterrupted,一样会继续尝试获取锁，失败则继续休眠。只是在最后获取锁成功后再把当前线程置为interrupted状态,然后再中断线程。 boolean tryLock(long ParamLong , TimeUnit ParamTimeUnit)throws InterruptedException尝试获取锁，如果能获取返回true,反则返回false,可加入时间限制和时间单位 unlock()对于拥有锁的线程释放锁 new Condition()应用比较复杂，单独分析返回用来与lock实例一起使用的Condition实例","tags":[{"name":"技术","slug":"技术","permalink":"https://wyanddw.github.io/tags/技术/"}]}]